보호 기법 중 유효-무효 비트에 대한 이전 논의는 주로 사용자 프로세스의 가상 메모리 관리 및 페이지 테이블 보호에 중점을 두었습니다. 이제 **메모리 관리**라는 더 큰 맥락에서 **NUMA(Non-Uniform Memory Access) 시스템의 메모리 관리**에 이어, **커널 메모리 할당**에 대한 출처의 내용을 종합적으로 논의하겠습니다. 커널 메모리 할당은 운영 체제 자체의 효율적이고 안정적인 작동에 필수적인 부분입니다.

---

**커널 메모리 할당 (Buddy System, Slab 할당자, SLOB, SLUB)과 메모리 관리**

메모리 관리에서 사용자 프로세스에 메모리를 할당하는 방식(예: 페이징)과 운영 체제 커널에 메모리를 할당하는 방식은 다릅니다. 커널은 자체 프로세스에 대해 **물리적으로 연속적인 페이지 (physically contiguous pages)** 형태로 메모리를 할당해야 하는 경우가 많습니다. 이는 특정 하드웨어 장치(예: DMA를 사용하는 I/O 장치)가 가상 메모리 인터페이스의 도움 없이 물리 메모리에 직접 상호 작용할 수 있기 때문입니다. 이러한 커널 메모리 요구 사항을 효율적으로 관리하기 위해 다양한 기법이 사용됩니다.

주요 커널 메모리 할당 전략은 다음과 같습니다:

1.  **버디 시스템 (Buddy System)**
    *   **정의 및 메커니즘**: **버디 시스템**은 **물리적으로 연속적인 페이지**로 구성된 고정 크기 세그먼트에서 메모리를 할당하는 기법입니다. 요청이 들어오면 2의 거듭제곱 단위(예: 4KB, 8KB, 16KB 등)로 할당하며, 적절한 크기가 아닐 경우 다음으로 가장 높은 2의 거듭제곱으로 반올림합니다. 예를 들어, 21KB 요청은 32KB 세그먼트로 충족됩니다.
    *   **예시**: 256KB 메모리 세그먼트에서 21KB를 요청하면, 256KB가 128KB 두 개의 버디로 나뉘고, 그중 하나가 다시 64KB 두 개의 버디로, 다시 32KB 두 개의 버디(CL과 CR)로 나뉘어 CL이 21KB 요청을 만족시키는 데 사용될 수 있습니다.
    *   **장점**: 인접한 버디들을 빠르게 결합하여 더 큰 세그먼트를 형성하는 **병합(coalescing)** 기술을 사용하여 메모리를 효율적으로 회수할 수 있습니다.
    *   **단점**: 2의 거듭제곱으로 반올림하는 특성 때문에 할당된 세그먼트 내에서 **내부 단편화 (Internal Fragmentation)**가 발생할 가능성이 높습니다. 할당된 단위의 절반 미만이 낭비될 수 있습니다.
    *   **Linux에서의 사용**: Linux 커널의 주된 물리 메모리 관리자인 **페이지 할당자(page allocator)**는 버디 시스템을 사용하여 사용 가능한 물리 페이지를 추적하고 요청 시 물리적으로 연속적인 페이지 범위를 할당합니다. Linux에서 이 메커니즘으로 할당할 수 있는 가장 작은 크기는 단일 물리 페이지입니다.

2.  **슬랩 할당자 (Slab Allocator)**
    *   **정의**: **슬랩 할당자**는 커널 메모리 할당의 또 다른 전략입니다. **슬랩 (Slab)**은 하나 이상의 **물리적으로 연속적인 페이지**로 구성됩니다. **캐시 (Cache)**는 하나 이상의 슬랩으로 구성되며, 각 고유한 커널 데이터 구조(예: 프로세스 디스크립터, 파일 객체, 세마포어)마다 별도의 캐시가 존재합니다. 각 캐시는 해당 커널 데이터 구조의 인스턴스인 **객체 (Object)**들로 채워집니다.
    *   **메커니즘**: 캐시가 생성될 때, 처음에 '사용 가능(free)'으로 표시된 여러 객체가 캐시에 할당됩니다. 새로운 커널 데이터 구조 객체가 필요하면, 할당자는 캐시에서 사용 가능한 객체를 할당하고 '사용 중(used)'으로 표시합니다.
    *   **슬랩의 상태**: Linux에서 슬랩은 세 가지 상태 중 하나일 수 있습니다:
        *   **Full (꽉 참)**: 슬랩의 모든 객체가 사용 중입니다.
        *   **Empty (비어 있음)**: 슬랩의 모든 객체가 사용 가능합니다.
        *   **Partial (부분)**: 슬랩에 사용 중인 객체와 사용 가능한 객체가 모두 있습니다.
        *   슬랩 할당자는 먼저 부분 슬랩에서 사용 가능한 객체를 찾고, 없으면 빈 슬랩에서, 그것도 없으면 새로운 슬랩을 할당하여 요청을 처리합니다.
    *   **예시**: Linux에서 프로세스 디스크립터는 약 1.7KB의 메모리를 필요로 하는 `struct task_struct` 타입입니다. 새로운 태스크(프로세스)를 생성할 때 커널은 해당 객체에 필요한 메모리를 캐시에서 요청합니다.
    *   **주요 이점**:
        *   **단편화 없음**: 각 고유한 커널 데이터 구조는 연관된 캐시를 가지며, 캐시는 객체 크기만큼의 조각으로 나뉜 슬랩으로 구성되므로, 정확히 필요한 만큼의 메모리가 반환되어 단편화가 발생하지 않습니다.
        *   **빠른 요청 처리**: 객체가 미리 생성되고 캐시에서 빠르게 할당될 수 있으며, 사용이 끝나면 즉시 재사용할 수 있도록 캐시로 반환되어 메모리 할당 및 해제가 빠릅니다. 이는 커널에서 객체가 빈번하게 할당되고 해제되는 상황에 특히 효율적입니다.
    *   **역사 및 채택**: 슬랩 할당자는 Solaris 2.4 커널에서 처음 등장했으며, Linux 커널은 버전 2.2부터 슬랩 할당자(SLAB이라고 부름)를 채택했습니다.

3.  **SLOB 할당자 (SLOB Allocator)**
    *   **특징**: **SLOB 할당자**("simple list of blocks"의 약자)는 임베디드 시스템과 같이 **메모리 양이 제한된 시스템**을 위해 설계되었습니다.
    *   **메커니즘**: SLOB은 세 가지 객체 목록(256바이트 미만의 객체를 위한 small, 1,024바이트 미만의 객체를 위한 medium, 페이지 크기 미만의 모든 다른 객체를 위한 large)을 유지하며, 해당 목록에서 첫 번째 적합한(`first-fit`) 정책을 사용하여 메모리 요청을 할당합니다.

4.  **SLUB 할당자 (SLUB Allocator)**
    *   **등장**: Linux 커널 버전 2.6.24부터 SLAB을 대체하는 기본 할당자로 도입되었습니다.
    *   **SLAB 대비 개선점**:
        *   SLAB 할당자에 비해 오버헤드가 크게 줄었습니다.
        *   SLAB이 각 슬랩에 메타데이터를 저장하는 반면, SLUB은 이 데이터를 Linux 커널이 각 페이지에 사용하는 페이지 구조에 저장합니다.
        *   SLAB이 각 캐시의 객체를 위해 유지하는 프로세서별 큐(per-CPU queues)를 SLUB은 포함하지 않습니다. 이는 많은 프로세서를 가진 시스템에서 상당한 메모리 양을 차지할 수 있으므로, SLUB은 프로세서 수가 증가함에 따라 더 나은 성능을 제공합니다.

**메모리 관리의 큰 맥락에서의 논의**

이러한 커널 메모리 할당 전략들은 운영 체제 전체 메모리 관리의 핵심적인 부분입니다. 사용자 프로세스의 메모리는 주로 **페이징**을 통해 **가상 주소 공간(logical address space)**이 물리 주소 공간과 분리되어 비연속적으로 할당될 수 있지만, 커널 자체는 효율성과 특정 하드웨어 요구사항(예: DMA)을 위해 **물리적으로 연속적인 메모리**를 필요로 합니다.

*   **버디 시스템**은 주로 큰 덩어리, 즉 물리 페이지(4KB 단위) 단위의 할당 및 해제를 효율적으로 처리하여 물리적 연속성을 유지합니다. 이는 가상 메모리 시스템이 물리 메모리에서 페이지 프레임을 관리하고 할당하는 데 기본이 됩니다.
*   그러나 커널은 페이지 단위보다 훨씬 작은, 다양한 크기의 작은 객체(예: 프로세스 디스크립터, 파일 객체)를 빈번하게 할당하고 해제해야 합니다. 이러한 작은 요청을 버디 시스템으로 처리하면 내부 단편화가 심해지고 효율성이 떨어집니다.
*   이러한 문제를 해결하기 위해 **슬랩 할당자**와 그 변형인 **SLOB, SLUB**가 도입되었습니다. 이들은 커널 데이터 구조의 특정 크기에 최적화된 "캐시"를 유지함으로써, 할당 시 단편화를 없애고 재사용성을 높여 할당/해제 오버헤드를 크게 줄입니다. 즉, 버디 시스템이 물리 페이지 블록을 관리하고, 슬랩 할당자가 이 페이지 블록 위에 커널의 작은 객체들을 효율적으로 관리하는 계층적 구조를 형성합니다.
*   NUMA 시스템과 같은 다중 프로세서 환경에서는 캐시의 효율성과 메모리 접근 시간 최소화가 중요하다고 이전 대화에서 논의했습니다. SLUB 할당자가 SLAB보다 많은 프로세서 시스템에서 더 나은 성능을 제공하는 것은 이러한 현대 아키텍처의 요구 사항을 반영합니다.

결론적으로, 커널 메모리 할당 기법들은 운영 체제 자체가 하드웨어 리소스를 효율적으로 관리하고 안정성을 유지하는 데 필수적인 저수준(low-level) 메커니즘입니다. 이들은 페이징 및 가상 메모리와 같은 고수준(high-level) 메모리 관리 기법을 지원하며, 현대 운영 체제 및 하드웨어 아키텍처의 복잡한 요구 사항에 맞춰 지속적으로 발전하고 있습니다.